#+property: header-args:python :tangle (concat (file-name-sans-extension (buffer-file-name)) ".py") :shebang "#!/usr/bin/env python3"
#+property: header-args :mkdirp yes :comments no

* 750words client
  :PROPERTIES:
  :CUSTOM_ID: words-client
  :END:

Allow programmatically posting text to 750words.com. Reads text from standard input, and adds it to your daily text. If the =--only-if-needed= flag is given, the text is only added if the current word count is less than 750 words. If the =--replace= flag is given, then any existing text is replaced instead of added to.

** Install dependencies
   :PROPERTIES:
   :CUSTOM_ID: install-dependencies
   :END:

Necessary libraries and software. This is commented out by default, kept here just as reference.

#+begin_src python :tangle no
# Install a pip package in the current Python install
import sys
# !{sys.executable} -m pip install selenium
#+end_src
#+begin_src python :tangle no
# !brew install google-chrome chromedriver
#+end_src

** Configuration and command line arguments

We configure the minimum and maximum word thresholds. The maximum may change if you have a paid 750words.com account, which allows you to write more than 5000 words.

#+begin_src python
min_words = 750
max_words = 4995
#+end_src

#+begin_src python
import argparse
import os
import sys
import time

parser = argparse.ArgumentParser(description="Interact with 750words.com from the command line.")
parser.add_argument('FILE',
                    help='Input files for text to add. Default is to read from standard input.',
                    type=argparse.FileType('r'),
                    nargs='*',
                    default=[sys.stdin],)
parser.add_argument("--min",
                    help=("Minimum number of words needed. Default: %d." % min_words),
                    default=min_words,
                    type=int)
parser.add_argument("--max",
                    help=("Maximum total number of words allowed. Default: %d." % max_words),
                    default=max_words)
parser.add_argument("--only-if-needed",
                    help="Only add text if current word count is below MIN.",
                    action="store_true")
parser.add_argument("--replace",
                    help="Replace any current text with the new one, default is to add at the end.",
                    action="store_true")
parser.add_argument("--count",
                    help="Don't upload text, only print the current word count.",
                    action="store_true")
parser.add_argument("--text",
                    help="Don't upload text, only print the current text.",
                    action="store_true")
parser.add_argument("--no-headless",
                    help="Disable headless mode (opens the Chrome app window).",
                    action="store_true")
parser.add_argument("--quiet",
                    help="Don't print progress messages.",
                    action="store_true")
parser.add_argument("--user",
                    help="User name to use for 750words. Can be provided through the USER_750WORDS environment variable.",
                    type=str,
                    default=(os.getenv('USER_750WORDS') or ""))
parser.add_argument("--password",
                    help="Password to use for authentication. Can be provided through the PASS_750WORDS environment variable.",
                    type=str,
                    default=(os.getenv('PASS_750WORDS') or ""))
args = parser.parse_args()
#+end_src

** Utility functions

Print a progress/status message to stderr.

#+begin_src python
def eprint(*eargs, **ekwargs):
    if not args.quiet:
        print(*eargs, file=sys.stderr, **ekwargs)
#+end_src
** Read text from stdin
   :PROPERTIES:
   :CUSTOM_ID: read-text-from-stdin
   :END:
#+begin_src python
text = ""
text_count = 0
if not (args.count or args.text):
    for infile in args.FILE:
        text = text + infile.read() + "\n"
    text_count = len(text.split())
    eprint("Got text: " + text + (" (%d words)" % text_count))
#+end_src

** Start up Chrome using Selenium and connect to 750words.com
   :PROPERTIES:
   :CUSTOM_ID: start-up-chrome-using-selenium-and-connect-to-750words.com
   :END:
#+begin_src python
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
#+end_src

#+begin_src python
opts = Options()
opts.add_argument("--window-size=1200,800")
if not args.no_headless:
    opts.add_argument("--headless")
opts.add_argument("--no-sandbox")
opts.add_argument("--disable-gpu")
opts.add_argument("--verbose")
opts.add_argument("--disable-setuid-sandbox")
opts.add_argument("--disable-dev-shm-usage")
opts.add_argument("--disable-infobars")

driver = webdriver.Chrome(options=opts)
#+end_src

#+begin_src python
eprint("Connecting to 750words.com...")
driver.get('https://750words.com/auth')
#+end_src
** Authenticate
   :PROPERTIES:
   :CUSTOM_ID: authenticate
   :END:
#+begin_src python
eprint("Authenticating...")
login_form = WebDriverWait(driver, 10).until(
    EC.presence_of_element_located((By.ID, 'signin_form'))
)
if login_form:
    user = driver.find_element_by_id('person_email_address')
    password = driver.find_element_by_id('person_password')
    user.send_keys(args.user)
    password.send_keys(args.password)
    login_form.submit()
else:
    raise BaseException("Could not find login form in https://750words.com/auth")
#+end_src

** Enter text
   :PROPERTIES:
   :CUSTOM_ID: enter-text
   :END:
#+begin_src python
eprint("Finding current text entry...")
# We use WebDriverWait to wait (with a limit) until the page is loaded and the
# necessary element appears.
# text_field = driver.find_element_by_id('entry_body')
text_field = WebDriverWait(driver, 10).until(
    EC.presence_of_element_located((By.ID, 'entry_body'))
)
if text_field:
    current_text = text_field.get_attribute("value")
    current_word_count = len(current_text.split())
    if args.count:
        print("Current word count: "+str(current_word_count))
    if args.text:
        print(current_text)
    if not (args.count or args.text):
        enter_text = True
        if (not args.replace) and args.only_if_needed and (current_word_count >= args.min):
            eprint("Word count is already enough, not entering text.")
            enter_text = False
        if enter_text:
            if args.replace:
                eprint("Clearing existing text...")
                text_field.clear()
                current_text = ""
                current_word_count = 0
            if (current_word_count+text_count) > args.max:
                new_word_count = args.max - current_word_count
                eprint("Trimming new text to %d words to keep total below %d" % (new_word_count, args.max))
                # This is imperfect - line breaks are replaced with spaces
                text = ' '.join(text.split()[:new_word_count])
            eprint("Entering new text...")
            text_field.send_keys(text)
            eprint("Saving...")
            ActionChains(driver).key_down(Keys.COMMAND).send_keys('s').key_up(Keys.COMMAND).perform()
            # If the warning dialog about losing words appears, click "Save
            # anyway"
            warning_dialog_text = driver.find_element_by_xpath('//div[@id="losing_words"]').text
            if warning_dialog_text:
                driver.find_element_by_xpath('//div[@class="ui-dialog-buttonset"]/button[1]').click()
            time.sleep(2)
            new_text = text_field.get_attribute("value")
            new_word_count = len(new_text.split())
            eprint("New word count: %d" % new_word_count)
            # Wait until the "Saved!" floating popup appears.
            # WebDriverWait(driver, 5).until(
            #     EC.presence_of_element_located((By.ID, 'achtung-overlay'))
            # )
else:
    raise BaseException("Could not find text entry form in page.")
#+end_src

** Finish
   :PROPERTIES:
   :CUSTOM_ID: finish
   :END:
#+begin_src python
eprint("Done!")
driver.quit()
#+end_src
